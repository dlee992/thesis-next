\section{实验设计和设置}
\input{table/table1.tex}

\subsection{系统实现}
\wa 技术在实验评估中使用 Java 语言实现，并使用 Apache POI 库 \footnote{https://poi.apache.org} 来读写 Excel 格式的电子表格。
相应源码发布在 GitHub 网站上 \footnote{https://github.com/dlee992/QRS19-Code} 。

\wa 工具总共包含约 7,300 行 Java 代码，除了包含 \cu 的源代码以外，额外增改了约 2,500 行代码。
类似于 \cu 的方式，\wa 标记它分析过的电子表格的方法是使用不同的背景色来标注检测到的同一张工作表内的所有单元格类，并通过在单元格右上角添加注释的方式标注含有公式缺陷的单元格的备注信息，包括所在类的信息和具体的公式缺陷种类。

\subsection{基准测试集} 
为了便于 \wa 和它的前身 \cu 进行比较，我们选择了 \cu 使用的采样自EUSES数据库的70 个电子表格，作为本文的实验基准测试集。
如表~\ref{table1}所示，该测试集包含 70 个电子表格和 291 个工作表。这 291 个工作表包含 189,027 个单元格，其中包含 26,716 个公式单元格。
出于实验评估的目的，该测试集额外包含人工标注的数据（标注的方法详见~\cite{cheung2016custodes})，其中包含 1,610 个单元格类和 1,974 个有公式缺陷的单元格。

\subsection{测试技术} 
在实验中， \wa 将和 5 个之前提到的电子表格缺陷检测技术进行对比，即 \uc、\di、\am、\ca 和 \cu 。
我们从它们各自的原作者那里获取了对应的可执行工具或源码。
除了 \ca 以外，其它技术的方法中并没有单元格类的概念，因此我们主要在缺陷检测的有效性方面对这些技术进行比较。
对于\ca，我们额外比较了它和 \wa 的单元格聚类的有效性。

为了评估三个有效性检验方法的独立性（研究问题3)，我们采用不同的配置来测试各自的实验效果，三种配置依次分别标记为 \wasc （含有针对单个单元格自身的有效性检验方法），\wamc （含有针对单元格之间关系的有效性检验方法），\wawc (含有针对整个类的有效性检验方法）。
最后，带有全部三种检验的配置被称为 \wa-full，简记为 \wa 。

\subsection{评价指标} 
为了衡量缺陷检测的有效性，我们首先统计每个技术检测出的缺陷数量，以及其中的真阳性（$TP$），假阳性（$FP$）和假阴性（$FN$）数量。
基于此，我们进一步根据如下三组公式计算精度 $precision_d$、召回率 $recall_d$ 和 $F\text{-}measure_d$ 值\cite{yoshida2010person}，来衡量电子表格缺陷检测上各技术的有效性。

\begin{gather*}
    precision_d=\frac{TP}{TP + FP}\qquad recall_d = \frac{TP}{TP + FN}\\
    f\text{-}measure_d = \frac{2 * precision_d * recall_d}{precision_d + recall_d}
\end{gather*}

针对电子表格缺陷的有效性（适用于 \wa 和 \cu），我们采用和 \cu 类似的方式来统计真阳性（$TP$），假阳性（$FP$）和假阴性（$FN$）数量\footnote{限于篇幅原因，具体统计方式可参考\cite{cheung2016custodes}第 6.2 节}。
类似地，我们也计算出这两个技术在单元格聚类上的精度 $precision_c$，召回率 $recall_c$和 \fmc 值。

\subsection{测试环境} 
所有实验在一台台式机上进行，配有 Intel$^\circledR$ Core\texttrademark\ i7-6700 CPU @3.41GHz 处理器和 64GB 内存。该机器上安装了微软 Windows 10 专业版操作系统和 Oracle Java 8 执行环境。

